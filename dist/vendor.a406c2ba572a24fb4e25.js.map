{"version":3,"sources":["webpack:///vendor.a406c2ba572a24fb4e25.js","webpack:///webpack/bootstrap d7a45487b59c9cc438d9","webpack:///./src/vendor.js","webpack:///./~/whatwg-fetch/fetch.js","webpack:///./~/lit-html/lit-html.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","shift","1","e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","0","appendChild","m","c","_interopRequireDefault","obj","__esModule","default","_whatwgFetch","self","normalizeName","name","String","test","TypeError","toLowerCase","normalizeValue","value","iteratorFor","items","iterator","next","done","support","iterable","Symbol","Headers","headers","this","map","forEach","append","Object","getOwnPropertyNames","consumed","body","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","onload","result","onerror","error","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","Body","_initBody","_bodyInit","_bodyText","Blob","prototype","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","searchParams","URLSearchParams","toString","arrayBuffer","ArrayBuffer","Error","get","set","rejected","then","text","decode","json","JSON","parse","normalizeMethod","method","upcased","toUpperCase","methods","indexOf","Request","input","options","url","credentials","mode","referrer","form","trim","split","bytes","replace","join","decodeURIComponent","xhr","pairs","getAllResponseHeaders","header","key","Response","bodyInit","status","ok","statusText","fetch","list","values","getAll","has","hasOwnProperty","thisArg","keys","entries","clone","response","redirectStatuses","redirect","RangeError","location","init","responseURL","getResponseHeader","request","XMLHttpRequest","responseText","ontimeout","open","withCredentials","responseType","setRequestHeader","send","polyfill","_classCallCheck","instance","Constructor","_taggedTemplateLiteral","strings","raw","freeze","defineProperties","litTag","templates","isSvg","envCachesTemplates","template","Template","TemplateResult","render","container","partCallback","arguments","defaultPartCallback","__templateInstance","_partCallback","update","TemplateInstance","fragment","_clone","child","lastChild","removeChild","defineProperty","_typeof","constructor","_createClass","target","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","_templateObject","t","s","Map","svgTemplates","html","_len","Array","_key","svg","_len2","_key2","attributeMarker","Math","random","textRegex","hasTagsRegex","textMarkerContent","textMarker","attrOrTextRegex","RegExp","TemplatePart","index","rawName","parts","element","innerHTML","_getHtml","walker","createTreeWalker","content","partIndex","nodesToRemove","previousNode","currentNode","nextNode","node","nodeType","hasAttributes","attributes","attribute","item","attributeStrings","attributeString","rawNameString","substring","match","removeAttribute","nodeValue","parent","parentNode","lastIndex","textContent","insertBefore","createTextNode","previousSibling","nextSibling","Text","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","n","err","l","a","isTextBinding","getValue","part","__litDirective","AttributePart","directive","f","size","startIndex","v","isArray","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","setAttribute","NodePart","startNode","endNode","_previousValue","_setText","_setTemplateResult","_setIterable","Node","_setNode","_setPromise","clear","_insert","TEXT_NODE","itemParts","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","itemPart","itemStart","previousPart","setValue","lastPart","_this","templatePart","_parts","valueIndex","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","importNode","svgElement","firstChild","nodes","childNodes"],"mappings":"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","file":"vendor.a406c2ba572a24fb4e25.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t1:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".\" + ({\"0\":\"main\"}[chunkId]||chunkId) + \".\" + {\"0\":\"b47e812913ad39494655\"}[chunkId] + \".js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _whatwgFetch = __webpack_require__(5);\n\t\n\tvar _whatwgFetch2 = _interopRequireDefault(_whatwgFetch);\n\t\n\tvar _litHtml = __webpack_require__(7);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ function(module, exports) {\n\n\t(function(self) {\n\t  'use strict';\n\t\n\t  if (self.fetch) {\n\t    return\n\t  }\n\t\n\t  var support = {\n\t    searchParams: 'URLSearchParams' in self,\n\t    iterable: 'Symbol' in self && 'iterator' in Symbol,\n\t    blob: 'FileReader' in self && 'Blob' in self && (function() {\n\t      try {\n\t        new Blob()\n\t        return true\n\t      } catch(e) {\n\t        return false\n\t      }\n\t    })(),\n\t    formData: 'FormData' in self,\n\t    arrayBuffer: 'ArrayBuffer' in self\n\t  }\n\t\n\t  function normalizeName(name) {\n\t    if (typeof name !== 'string') {\n\t      name = String(name)\n\t    }\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t      throw new TypeError('Invalid character in header field name')\n\t    }\n\t    return name.toLowerCase()\n\t  }\n\t\n\t  function normalizeValue(value) {\n\t    if (typeof value !== 'string') {\n\t      value = String(value)\n\t    }\n\t    return value\n\t  }\n\t\n\t  // Build a destructive iterator for the value list\n\t  function iteratorFor(items) {\n\t    var iterator = {\n\t      next: function() {\n\t        var value = items.shift()\n\t        return {done: value === undefined, value: value}\n\t      }\n\t    }\n\t\n\t    if (support.iterable) {\n\t      iterator[Symbol.iterator] = function() {\n\t        return iterator\n\t      }\n\t    }\n\t\n\t    return iterator\n\t  }\n\t\n\t  function Headers(headers) {\n\t    this.map = {}\n\t\n\t    if (headers instanceof Headers) {\n\t      headers.forEach(function(value, name) {\n\t        this.append(name, value)\n\t      }, this)\n\t\n\t    } else if (headers) {\n\t      Object.getOwnPropertyNames(headers).forEach(function(name) {\n\t        this.append(name, headers[name])\n\t      }, this)\n\t    }\n\t  }\n\t\n\t  Headers.prototype.append = function(name, value) {\n\t    name = normalizeName(name)\n\t    value = normalizeValue(value)\n\t    var list = this.map[name]\n\t    if (!list) {\n\t      list = []\n\t      this.map[name] = list\n\t    }\n\t    list.push(value)\n\t  }\n\t\n\t  Headers.prototype['delete'] = function(name) {\n\t    delete this.map[normalizeName(name)]\n\t  }\n\t\n\t  Headers.prototype.get = function(name) {\n\t    var values = this.map[normalizeName(name)]\n\t    return values ? values[0] : null\n\t  }\n\t\n\t  Headers.prototype.getAll = function(name) {\n\t    return this.map[normalizeName(name)] || []\n\t  }\n\t\n\t  Headers.prototype.has = function(name) {\n\t    return this.map.hasOwnProperty(normalizeName(name))\n\t  }\n\t\n\t  Headers.prototype.set = function(name, value) {\n\t    this.map[normalizeName(name)] = [normalizeValue(value)]\n\t  }\n\t\n\t  Headers.prototype.forEach = function(callback, thisArg) {\n\t    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n\t      this.map[name].forEach(function(value) {\n\t        callback.call(thisArg, value, name, this)\n\t      }, this)\n\t    }, this)\n\t  }\n\t\n\t  Headers.prototype.keys = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push(name) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.values = function() {\n\t    var items = []\n\t    this.forEach(function(value) { items.push(value) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.entries = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push([name, value]) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  if (support.iterable) {\n\t    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n\t  }\n\t\n\t  function consumed(body) {\n\t    if (body.bodyUsed) {\n\t      return Promise.reject(new TypeError('Already read'))\n\t    }\n\t    body.bodyUsed = true\n\t  }\n\t\n\t  function fileReaderReady(reader) {\n\t    return new Promise(function(resolve, reject) {\n\t      reader.onload = function() {\n\t        resolve(reader.result)\n\t      }\n\t      reader.onerror = function() {\n\t        reject(reader.error)\n\t      }\n\t    })\n\t  }\n\t\n\t  function readBlobAsArrayBuffer(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsArrayBuffer(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  function readBlobAsText(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsText(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  function Body() {\n\t    this.bodyUsed = false\n\t\n\t    this._initBody = function(body) {\n\t      this._bodyInit = body\n\t      if (typeof body === 'string') {\n\t        this._bodyText = body\n\t      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n\t        this._bodyBlob = body\n\t      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n\t        this._bodyFormData = body\n\t      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t        this._bodyText = body.toString()\n\t      } else if (!body) {\n\t        this._bodyText = ''\n\t      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n\t        // Only support ArrayBuffers for POST method.\n\t        // Receiving ArrayBuffers happens via Blobs, instead.\n\t      } else {\n\t        throw new Error('unsupported BodyInit type')\n\t      }\n\t\n\t      if (!this.headers.get('content-type')) {\n\t        if (typeof body === 'string') {\n\t          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n\t        } else if (this._bodyBlob && this._bodyBlob.type) {\n\t          this.headers.set('content-type', this._bodyBlob.type)\n\t        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n\t        }\n\t      }\n\t    }\n\t\n\t    if (support.blob) {\n\t      this.blob = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return Promise.resolve(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as blob')\n\t        } else {\n\t          return Promise.resolve(new Blob([this._bodyText]))\n\t        }\n\t      }\n\t\n\t      this.arrayBuffer = function() {\n\t        return this.blob().then(readBlobAsArrayBuffer)\n\t      }\n\t\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return readBlobAsText(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as text')\n\t        } else {\n\t          return Promise.resolve(this._bodyText)\n\t        }\n\t      }\n\t    } else {\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        return rejected ? rejected : Promise.resolve(this._bodyText)\n\t      }\n\t    }\n\t\n\t    if (support.formData) {\n\t      this.formData = function() {\n\t        return this.text().then(decode)\n\t      }\n\t    }\n\t\n\t    this.json = function() {\n\t      return this.text().then(JSON.parse)\n\t    }\n\t\n\t    return this\n\t  }\n\t\n\t  // HTTP methods whose capitalization should be normalized\n\t  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\t\n\t  function normalizeMethod(method) {\n\t    var upcased = method.toUpperCase()\n\t    return (methods.indexOf(upcased) > -1) ? upcased : method\n\t  }\n\t\n\t  function Request(input, options) {\n\t    options = options || {}\n\t    var body = options.body\n\t    if (Request.prototype.isPrototypeOf(input)) {\n\t      if (input.bodyUsed) {\n\t        throw new TypeError('Already read')\n\t      }\n\t      this.url = input.url\n\t      this.credentials = input.credentials\n\t      if (!options.headers) {\n\t        this.headers = new Headers(input.headers)\n\t      }\n\t      this.method = input.method\n\t      this.mode = input.mode\n\t      if (!body) {\n\t        body = input._bodyInit\n\t        input.bodyUsed = true\n\t      }\n\t    } else {\n\t      this.url = input\n\t    }\n\t\n\t    this.credentials = options.credentials || this.credentials || 'omit'\n\t    if (options.headers || !this.headers) {\n\t      this.headers = new Headers(options.headers)\n\t    }\n\t    this.method = normalizeMethod(options.method || this.method || 'GET')\n\t    this.mode = options.mode || this.mode || null\n\t    this.referrer = null\n\t\n\t    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n\t      throw new TypeError('Body not allowed for GET or HEAD requests')\n\t    }\n\t    this._initBody(body)\n\t  }\n\t\n\t  Request.prototype.clone = function() {\n\t    return new Request(this)\n\t  }\n\t\n\t  function decode(body) {\n\t    var form = new FormData()\n\t    body.trim().split('&').forEach(function(bytes) {\n\t      if (bytes) {\n\t        var split = bytes.split('=')\n\t        var name = split.shift().replace(/\\+/g, ' ')\n\t        var value = split.join('=').replace(/\\+/g, ' ')\n\t        form.append(decodeURIComponent(name), decodeURIComponent(value))\n\t      }\n\t    })\n\t    return form\n\t  }\n\t\n\t  function headers(xhr) {\n\t    var head = new Headers()\n\t    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\\n')\n\t    pairs.forEach(function(header) {\n\t      var split = header.trim().split(':')\n\t      var key = split.shift().trim()\n\t      var value = split.join(':').trim()\n\t      head.append(key, value)\n\t    })\n\t    return head\n\t  }\n\t\n\t  Body.call(Request.prototype)\n\t\n\t  function Response(bodyInit, options) {\n\t    if (!options) {\n\t      options = {}\n\t    }\n\t\n\t    this.type = 'default'\n\t    this.status = options.status\n\t    this.ok = this.status >= 200 && this.status < 300\n\t    this.statusText = options.statusText\n\t    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n\t    this.url = options.url || ''\n\t    this._initBody(bodyInit)\n\t  }\n\t\n\t  Body.call(Response.prototype)\n\t\n\t  Response.prototype.clone = function() {\n\t    return new Response(this._bodyInit, {\n\t      status: this.status,\n\t      statusText: this.statusText,\n\t      headers: new Headers(this.headers),\n\t      url: this.url\n\t    })\n\t  }\n\t\n\t  Response.error = function() {\n\t    var response = new Response(null, {status: 0, statusText: ''})\n\t    response.type = 'error'\n\t    return response\n\t  }\n\t\n\t  var redirectStatuses = [301, 302, 303, 307, 308]\n\t\n\t  Response.redirect = function(url, status) {\n\t    if (redirectStatuses.indexOf(status) === -1) {\n\t      throw new RangeError('Invalid status code')\n\t    }\n\t\n\t    return new Response(null, {status: status, headers: {location: url}})\n\t  }\n\t\n\t  self.Headers = Headers\n\t  self.Request = Request\n\t  self.Response = Response\n\t\n\t  self.fetch = function(input, init) {\n\t    return new Promise(function(resolve, reject) {\n\t      var request\n\t      if (Request.prototype.isPrototypeOf(input) && !init) {\n\t        request = input\n\t      } else {\n\t        request = new Request(input, init)\n\t      }\n\t\n\t      var xhr = new XMLHttpRequest()\n\t\n\t      function responseURL() {\n\t        if ('responseURL' in xhr) {\n\t          return xhr.responseURL\n\t        }\n\t\n\t        // Avoid security warnings on getResponseHeader when not allowed by CORS\n\t        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n\t          return xhr.getResponseHeader('X-Request-URL')\n\t        }\n\t\n\t        return\n\t      }\n\t\n\t      xhr.onload = function() {\n\t        var options = {\n\t          status: xhr.status,\n\t          statusText: xhr.statusText,\n\t          headers: headers(xhr),\n\t          url: responseURL()\n\t        }\n\t        var body = 'response' in xhr ? xhr.response : xhr.responseText\n\t        resolve(new Response(body, options))\n\t      }\n\t\n\t      xhr.onerror = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.ontimeout = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.open(request.method, request.url, true)\n\t\n\t      if (request.credentials === 'include') {\n\t        xhr.withCredentials = true\n\t      }\n\t\n\t      if ('responseType' in xhr && support.blob) {\n\t        xhr.responseType = 'blob'\n\t      }\n\t\n\t      request.headers.forEach(function(value, name) {\n\t        xhr.setRequestHeader(name, value)\n\t      })\n\t\n\t      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n\t    })\n\t  }\n\t  self.fetch.polyfill = true\n\t})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ },\n/* 6 */,\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _templateObject = _taggedTemplateLiteral([''], ['']);\n\t\n\texports.render = render;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\t\n\t/**\n\t * @license\n\t * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n\t * This code may only be used under the BSD style license found at\n\t * http://polymer.github.io/LICENSE.txt\n\t * The complete set of authors may be found at\n\t * http://polymer.github.io/AUTHORS.txt\n\t * The complete set of contributors may be found at\n\t * http://polymer.github.io/CONTRIBUTORS.txt\n\t * Code distributed by Google as part of the polymer project is also\n\t * subject to an additional IP rights grant found at\n\t * http://polymer.github.io/PATENTS.txt\n\t */\n\t/**\n\t * TypeScript has a problem with precompiling templates literals\n\t * https://github.com/Microsoft/TypeScript/issues/17956\n\t *\n\t * TODO(justinfagnani): Run tests compiled to ES5 with both Babel and\n\t * TypeScript to verify correctness.\n\t */\n\tvar envCachesTemplates = function (t) {\n\t    return t() === t();\n\t}(function () {\n\t    return function (s) {\n\t        return s;\n\t    }(_templateObject);\n\t});\n\t// The first argument to JS template tags retain identity across multiple\n\t// calls to a tag for the same literal, so we can cache work done per literal\n\t// in a Map.\n\tvar templates = new Map();\n\tvar svgTemplates = new Map();\n\t/**\n\t * Interprets a template literal as an HTML template that can efficiently\n\t * render to and update a container.\n\t */\n\tvar html = exports.html = function html(strings) {\n\t    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        values[_key - 1] = arguments[_key];\n\t    }\n\t\n\t    return litTag(strings, values, templates, false);\n\t};\n\t/**\n\t * Interprets a template literal as an SVG template that can efficiently\n\t * render to and update a container.\n\t */\n\tvar svg = exports.svg = function svg(strings) {\n\t    for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t        values[_key2 - 1] = arguments[_key2];\n\t    }\n\t\n\t    return litTag(strings, values, svgTemplates, true);\n\t};\n\tfunction litTag(strings, values, templates, isSvg) {\n\t    var key = envCachesTemplates ? strings : strings.join('{{--uniqueness-workaround--}}');\n\t    var template = templates.get(key);\n\t    if (template === undefined) {\n\t        template = new Template(strings, isSvg);\n\t        templates.set(key, template);\n\t    }\n\t    return new TemplateResult(template, values);\n\t}\n\t/**\n\t * The return type of `html`, which holds a Template and the values from\n\t * interpolated expressions.\n\t */\n\t\n\tvar TemplateResult = exports.TemplateResult = function TemplateResult(template, values) {\n\t    _classCallCheck(this, TemplateResult);\n\t\n\t    this.template = template;\n\t    this.values = values;\n\t};\n\t/**\n\t * Renders a template to a container.\n\t *\n\t * To update a container with new values, reevaluate the template literal and\n\t * call `render` with the new result.\n\t */\n\t\n\t\n\tfunction render(result, container) {\n\t    var partCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultPartCallback;\n\t\n\t    var instance = container.__templateInstance;\n\t    // Repeat render, just call update()\n\t    if (instance !== undefined && instance.template === result.template && instance._partCallback === partCallback) {\n\t        instance.update(result.values);\n\t        return;\n\t    }\n\t    // First render, create a new TemplateInstance and append it\n\t    instance = new TemplateInstance(result.template, partCallback);\n\t    container.__templateInstance = instance;\n\t    var fragment = instance._clone();\n\t    instance.update(result.values);\n\t    var child = void 0;\n\t    while (child = container.lastChild) {\n\t        container.removeChild(child);\n\t    }\n\t    container.appendChild(fragment);\n\t}\n\t/**\n\t * An expression marker with embedded unique key to avoid\n\t * https://github.com/PolymerLabs/lit-html/issues/62\n\t */\n\tvar attributeMarker = '{{lit-' + Math.random() + '}}';\n\t/**\n\t * Regex to scan the string preceding an expression to see if we're in a text\n\t * context, and not an attribute context.\n\t *\n\t * This works by seeing if we have a `>` not followed by a `<`. If there is a\n\t * `<` closer to the end of the strings, then we're inside a tag.\n\t */\n\tvar textRegex = />[^<]*$/;\n\tvar hasTagsRegex = /[^<]*/;\n\tvar textMarkerContent = '_-lit-html-_';\n\tvar textMarker = '<!--' + textMarkerContent + '-->';\n\tvar attrOrTextRegex = new RegExp(attributeMarker + '|' + textMarker);\n\t/**\n\t * A placeholder for a dynamic expression in an HTML template.\n\t *\n\t * There are two built-in part types: AttributePart and NodePart. NodeParts\n\t * always represent a single dynamic expression, while AttributeParts may\n\t * represent as many expressions are contained in the attribute.\n\t *\n\t * A Template's parts are mutable, so parts can be replaced or modified\n\t * (possibly to implement different template semantics). The contract is that\n\t * parts can only be replaced, not removed, added or reordered, and parts must\n\t * always consume the correct number of values in their `update()` method.\n\t *\n\t * TODO(justinfagnani): That requirement is a little fragile. A\n\t * TemplateInstance could instead be more careful about which values it gives\n\t * to Part.update().\n\t */\n\t\n\tvar TemplatePart = exports.TemplatePart = function TemplatePart(type, index, name, rawName, strings) {\n\t    _classCallCheck(this, TemplatePart);\n\t\n\t    this.type = type;\n\t    this.index = index;\n\t    this.name = name;\n\t    this.rawName = rawName;\n\t    this.strings = strings;\n\t};\n\t\n\tvar Template = exports.Template = function () {\n\t    function Template(strings) {\n\t        var svg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        _classCallCheck(this, Template);\n\t\n\t        this.parts = [];\n\t        this.svg = svg;\n\t        this.element = document.createElement('template');\n\t        this.element.innerHTML = this._getHtml(strings, svg);\n\t        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n\t        var walker = document.createTreeWalker(this.element.content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n\t                                                                         NodeFilter.SHOW_TEXT */, null, false);\n\t        var index = -1;\n\t        var partIndex = 0;\n\t        var nodesToRemove = [];\n\t        // The actual previous node, accounting for removals: if a node is removed\n\t        // it will never be the previousNode.\n\t        var previousNode = void 0;\n\t        // Used to set previousNode at the top of the loop.\n\t        var currentNode = void 0;\n\t        while (walker.nextNode()) {\n\t            index++;\n\t            previousNode = currentNode;\n\t            var node = currentNode = walker.currentNode;\n\t            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n\t                    if (!node.hasAttributes()) {\n\t                        continue;\n\t                    }\n\t                    var attributes = node.attributes;\n\t                    for (var i = 0; i < attributes.length; i++) {\n\t                        var attribute = attributes.item(i);\n\t                        var attributeStrings = attribute.value.split(attrOrTextRegex);\n\t                        if (attributeStrings.length > 1) {\n\t                            // Get the template literal section leading up to the first\n\t                            // expression in this attribute attribute\n\t                            var attributeString = strings[partIndex];\n\t                            // Trim the trailing literal value if this is an interpolation\n\t                            var rawNameString = attributeString.substring(0, attributeString.length - attributeStrings[0].length);\n\t                            // Find the attribute name\n\t                            var rawName = rawNameString.match(/((?:\\w|[.\\-_$])+)=[\"']?$/)[1];\n\t                            this.parts.push(new TemplatePart('attribute', index, attribute.name, rawName, attributeStrings));\n\t                            node.removeAttribute(attribute.name);\n\t                            partIndex += attributeStrings.length - 1;\n\t                            i--;\n\t                        }\n\t                    }\n\t                } else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n\t                    var nodeValue = node.nodeValue;\n\t                    var _strings = nodeValue.split(attributeMarker);\n\t                    if (_strings.length > 1) {\n\t                        var parent = node.parentNode;\n\t                        var lastIndex = _strings.length - 1;\n\t                        // We have a part for each match found\n\t                        partIndex += lastIndex;\n\t                        // We keep this current node, but reset its content to the last\n\t                        // literal part. We insert new literal nodes before this so that the\n\t                        // tree walker keeps its position correctly.\n\t                        node.textContent = _strings[lastIndex];\n\t                        // Generate a new text node for each literal section\n\t                        // These nodes are also used as the markers for node parts\n\t                        for (var _i = 0; _i < lastIndex; _i++) {\n\t                            parent.insertBefore(document.createTextNode(_strings[_i]), node);\n\t                            this.parts.push(new TemplatePart('node', index++));\n\t                        }\n\t                    } else {\n\t                        // Strip whitespace-only nodes, only between elements, or at the\n\t                        // beginning or end of elements.\n\t                        var previousSibling = node.previousSibling;\n\t                        var nextSibling = node.nextSibling;\n\t                        if ((previousSibling === null || previousSibling.nodeType === 1 /* Node.ELEMENT_NODE */) && (nextSibling === null || nextSibling.nodeType === 1 /* Node.ELEMENT_NODE */) && nodeValue.trim() === '') {\n\t                            nodesToRemove.push(node);\n\t                            currentNode = previousNode;\n\t                            index--;\n\t                        }\n\t                    }\n\t                } else if (node.nodeType === 8 /* Node.COMMENT_NODE */ && node.nodeValue === textMarkerContent) {\n\t                var _parent = node.parentNode;\n\t                // If we don't have a previous node add a marker node.\n\t                // If the previousSibling is removed, because it's another part\n\t                // placholder, or empty text, add a marker node.\n\t                if (node.previousSibling === null || node.previousSibling !== previousNode) {\n\t                    _parent.insertBefore(new Text(), node);\n\t                } else {\n\t                    index--;\n\t                }\n\t                this.parts.push(new TemplatePart('node', index++));\n\t                nodesToRemove.push(node);\n\t                // If we don't have a next node add a marker node.\n\t                // We don't have to check if the next node is going to be removed,\n\t                // because that node will induce a marker if so.\n\t                if (node.nextSibling === null) {\n\t                    _parent.insertBefore(new Text(), node);\n\t                } else {\n\t                    index--;\n\t                }\n\t                currentNode = previousNode;\n\t                partIndex++;\n\t            }\n\t        }\n\t        // Remove text binding nodes after the walk to not disturb the TreeWalker\n\t        var _iteratorNormalCompletion = true;\n\t        var _didIteratorError = false;\n\t        var _iteratorError = undefined;\n\t\n\t        try {\n\t            for (var _iterator = nodesToRemove[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                var n = _step.value;\n\t\n\t                n.parentNode.removeChild(n);\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError = true;\n\t            _iteratorError = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion && _iterator.return) {\n\t                    _iterator.return();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError) {\n\t                    throw _iteratorError;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * Returns a string of HTML used to create a <template> element.\n\t     */\n\t\n\t\n\t    _createClass(Template, [{\n\t        key: '_getHtml',\n\t        value: function _getHtml(strings, svg) {\n\t            var l = strings.length;\n\t            var a = [];\n\t            var isTextBinding = false;\n\t            for (var i = 0; i < l - 1; i++) {\n\t                var s = strings[i];\n\t                a.push(s);\n\t                // We're in a text position if the previous string matches the\n\t                // textRegex. If it doesn't and the previous string has no tags, then\n\t                // we use the previous text position state.\n\t                isTextBinding = s.match(textRegex) !== null || s.match(hasTagsRegex) !== null && isTextBinding;\n\t                a.push(isTextBinding ? textMarker : attributeMarker);\n\t            }\n\t            a.push(strings[l - 1]);\n\t            var html = a.join('');\n\t            return svg ? '<svg>' + html + '</svg>' : html;\n\t        }\n\t    }]);\n\t\n\t    return Template;\n\t}();\n\t\n\tvar getValue = exports.getValue = function getValue(part, value) {\n\t    // `null` as the value of a Text node will render the string 'null'\n\t    // so we convert it to undefined\n\t    if (value != null && value.__litDirective === true) {\n\t        value = value(part);\n\t    }\n\t    return value === null ? undefined : value;\n\t};\n\tvar directive = exports.directive = function directive(f) {\n\t    f.__litDirective = true;\n\t    return f;\n\t};\n\t\n\tvar AttributePart = exports.AttributePart = function () {\n\t    function AttributePart(instance, element, name, strings) {\n\t        _classCallCheck(this, AttributePart);\n\t\n\t        this.instance = instance;\n\t        this.element = element;\n\t        this.name = name;\n\t        this.strings = strings;\n\t        this.size = strings.length - 1;\n\t    }\n\t\n\t    _createClass(AttributePart, [{\n\t        key: 'setValue',\n\t        value: function setValue(values, startIndex) {\n\t            var strings = this.strings;\n\t            var text = '';\n\t            for (var i = 0; i < strings.length; i++) {\n\t                text += strings[i];\n\t                if (i < strings.length - 1) {\n\t                    var v = getValue(this, values[startIndex + i]);\n\t                    if (v && (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n\t                        var _iteratorNormalCompletion2 = true;\n\t                        var _didIteratorError2 = false;\n\t                        var _iteratorError2 = undefined;\n\t\n\t                        try {\n\t                            for (var _iterator2 = v[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                                var t = _step2.value;\n\t\n\t                                // TODO: we need to recursively call getValue into iterables...\n\t                                text += t;\n\t                            }\n\t                        } catch (err) {\n\t                            _didIteratorError2 = true;\n\t                            _iteratorError2 = err;\n\t                        } finally {\n\t                            try {\n\t                                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                                    _iterator2.return();\n\t                                }\n\t                            } finally {\n\t                                if (_didIteratorError2) {\n\t                                    throw _iteratorError2;\n\t                                }\n\t                            }\n\t                        }\n\t                    } else {\n\t                        text += v;\n\t                    }\n\t                }\n\t            }\n\t            this.element.setAttribute(this.name, text);\n\t        }\n\t    }]);\n\t\n\t    return AttributePart;\n\t}();\n\t\n\tvar NodePart = exports.NodePart = function () {\n\t    function NodePart(instance, startNode, endNode) {\n\t        _classCallCheck(this, NodePart);\n\t\n\t        this.instance = instance;\n\t        this.startNode = startNode;\n\t        this.endNode = endNode;\n\t        this._previousValue = undefined;\n\t    }\n\t\n\t    _createClass(NodePart, [{\n\t        key: 'setValue',\n\t        value: function setValue(value) {\n\t            value = getValue(this, value);\n\t            if (value === null || !((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' || typeof value === 'function')) {\n\t                // Handle primitive values\n\t                // If the value didn't change, do nothing\n\t                if (value === this._previousValue) {\n\t                    return;\n\t                }\n\t                this._setText(value);\n\t            } else if (value instanceof TemplateResult) {\n\t                this._setTemplateResult(value);\n\t            } else if (Array.isArray(value) || value[Symbol.iterator]) {\n\t                this._setIterable(value);\n\t            } else if (value instanceof Node) {\n\t                this._setNode(value);\n\t            } else if (value.then !== undefined) {\n\t                this._setPromise(value);\n\t            } else {\n\t                // Fallback, will render the string representation\n\t                this._setText(value);\n\t            }\n\t        }\n\t    }, {\n\t        key: '_insert',\n\t        value: function _insert(node) {\n\t            this.endNode.parentNode.insertBefore(node, this.endNode);\n\t        }\n\t    }, {\n\t        key: '_setNode',\n\t        value: function _setNode(value) {\n\t            this.clear();\n\t            this._insert(value);\n\t            this._previousValue = value;\n\t        }\n\t    }, {\n\t        key: '_setText',\n\t        value: function _setText(value) {\n\t            var node = this.startNode.nextSibling;\n\t            if (node === this.endNode.previousSibling && node.nodeType === Node.TEXT_NODE) {\n\t                // If we only have a single text node between the markers, we can just\n\t                // set its value, rather than replacing it.\n\t                // TODO(justinfagnani): Can we just check if _previousValue is\n\t                // primitive?\n\t                node.textContent = value;\n\t            } else {\n\t                this._setNode(document.createTextNode(value === undefined ? '' : value));\n\t            }\n\t            this._previousValue = value;\n\t        }\n\t    }, {\n\t        key: '_setTemplateResult',\n\t        value: function _setTemplateResult(value) {\n\t            var instance = void 0;\n\t            if (this._previousValue && this._previousValue.template === value.template) {\n\t                instance = this._previousValue;\n\t            } else {\n\t                instance = new TemplateInstance(value.template, this.instance._partCallback);\n\t                this._setNode(instance._clone());\n\t                this._previousValue = instance;\n\t            }\n\t            instance.update(value.values);\n\t        }\n\t    }, {\n\t        key: '_setIterable',\n\t        value: function _setIterable(value) {\n\t            // For an Iterable, we create a new InstancePart per item, then set its\n\t            // value to the item. This is a little bit of overhead for every item in\n\t            // an Iterable, but it lets us recurse easily and efficiently update Arrays\n\t            // of TemplateResults that will be commonly returned from expressions like:\n\t            // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\t            // If _previousValue is an array, then the previous render was of an\n\t            // iterable and _previousValue will contain the NodeParts from the previous\n\t            // render. If _previousValue is not an array, clear this part and make a new\n\t            // array for NodeParts.\n\t            if (!Array.isArray(this._previousValue)) {\n\t                this.clear();\n\t                this._previousValue = [];\n\t            }\n\t            // Lets us keep track of how many items we stamped so we can clear leftover\n\t            // items from a previous render\n\t            var itemParts = this._previousValue;\n\t            var partIndex = 0;\n\t            var _iteratorNormalCompletion3 = true;\n\t            var _didIteratorError3 = false;\n\t            var _iteratorError3 = undefined;\n\t\n\t            try {\n\t                for (var _iterator3 = value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t                    var item = _step3.value;\n\t\n\t                    // Try to reuse an existing part\n\t                    var itemPart = itemParts[partIndex];\n\t                    // If no existing part, create a new one\n\t                    if (itemPart === undefined) {\n\t                        // If we're creating the first item part, it's startNode should be the\n\t                        // container's startNode\n\t                        var itemStart = this.startNode;\n\t                        // If we're not creating the first part, create a new separator marker\n\t                        // node, and fix up the previous part's endNode to point to it\n\t                        if (partIndex > 0) {\n\t                            var previousPart = itemParts[partIndex - 1];\n\t                            itemStart = previousPart.endNode = document.createTextNode('');\n\t                            this._insert(itemStart);\n\t                        }\n\t                        itemPart = new NodePart(this.instance, itemStart, this.endNode);\n\t                        itemParts.push(itemPart);\n\t                    }\n\t                    itemPart.setValue(item);\n\t                    partIndex++;\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError3 = true;\n\t                _iteratorError3 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                        _iterator3.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError3) {\n\t                        throw _iteratorError3;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (partIndex === 0) {\n\t                this.clear();\n\t                this._previousValue = undefined;\n\t            } else if (partIndex < itemParts.length) {\n\t                var lastPart = itemParts[partIndex - 1];\n\t                // Truncate the parts array so _previousValue reflects the current state\n\t                itemParts.length = partIndex;\n\t                this.clear(lastPart.endNode.previousSibling);\n\t                lastPart.endNode = this.endNode;\n\t            }\n\t        }\n\t    }, {\n\t        key: '_setPromise',\n\t        value: function _setPromise(value) {\n\t            var _this = this;\n\t\n\t            value.then(function (v) {\n\t                if (_this._previousValue === value) {\n\t                    _this.setValue(v);\n\t                }\n\t            });\n\t            this._previousValue = value;\n\t        }\n\t    }, {\n\t        key: 'clear',\n\t        value: function clear() {\n\t            var startNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.startNode;\n\t\n\t            var node = void 0;\n\t            while ((node = startNode.nextSibling) !== this.endNode) {\n\t                node.parentNode.removeChild(node);\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return NodePart;\n\t}();\n\t\n\tvar defaultPartCallback = exports.defaultPartCallback = function defaultPartCallback(instance, templatePart, node) {\n\t    if (templatePart.type === 'attribute') {\n\t        return new AttributePart(instance, node, templatePart.name, templatePart.strings);\n\t    } else if (templatePart.type === 'node') {\n\t        return new NodePart(instance, node, node.nextSibling);\n\t    }\n\t    throw new Error('Unknown part type ' + templatePart.type);\n\t};\n\t/**\n\t * An instance of a `Template` that can be attached to the DOM and updated\n\t * with new values.\n\t */\n\t\n\tvar TemplateInstance = exports.TemplateInstance = function () {\n\t    function TemplateInstance(template) {\n\t        var partCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultPartCallback;\n\t\n\t        _classCallCheck(this, TemplateInstance);\n\t\n\t        this._parts = [];\n\t        this.template = template;\n\t        this._partCallback = partCallback;\n\t    }\n\t\n\t    _createClass(TemplateInstance, [{\n\t        key: 'update',\n\t        value: function update(values) {\n\t            var valueIndex = 0;\n\t            var _iteratorNormalCompletion4 = true;\n\t            var _didIteratorError4 = false;\n\t            var _iteratorError4 = undefined;\n\t\n\t            try {\n\t                for (var _iterator4 = this._parts[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t                    var part = _step4.value;\n\t\n\t                    if (part.size === undefined) {\n\t                        part.setValue(values[valueIndex]);\n\t                        valueIndex++;\n\t                    } else {\n\t                        part.setValue(values, valueIndex);\n\t                        valueIndex += part.size;\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError4 = true;\n\t                _iteratorError4 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t                        _iterator4.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError4) {\n\t                        throw _iteratorError4;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }, {\n\t        key: '_clone',\n\t        value: function _clone() {\n\t            var fragment = document.importNode(this.template.element.content, true);\n\t            if (this.template.parts.length > 0) {\n\t                // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n\t                // null\n\t                var _walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT */, null, false);\n\t                var parts = this.template.parts;\n\t                var _index = 0;\n\t                var _partIndex = 0;\n\t                var templatePart = parts[0];\n\t                var node = _walker.nextNode();\n\t                while (node != null && _partIndex < parts.length) {\n\t                    if (_index === templatePart.index) {\n\t                        this._parts.push(this._partCallback(this, templatePart, node));\n\t                        templatePart = parts[++_partIndex];\n\t                    } else {\n\t                        _index++;\n\t                        node = _walker.nextNode();\n\t                    }\n\t                }\n\t            }\n\t            if (this.template.svg) {\n\t                var svgElement = fragment.firstChild;\n\t                fragment.removeChild(svgElement);\n\t                var nodes = svgElement.childNodes;\n\t                for (var i = 0; i < nodes.length; i++) {\n\t                    fragment.appendChild(nodes.item(i));\n\t                }\n\t            }\n\t            return fragment;\n\t        }\n\t    }]);\n\t\n\t    return TemplateInstance;\n\t}();\n\t//# sourceMappingURL=lit-html.js.map\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** vendor.a406c2ba572a24fb4e25.js\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t1:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".\" + ({\"0\":\"main\"}[chunkId]||chunkId) + \".\" + {\"0\":\"b47e812913ad39494655\"}[chunkId] + \".js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d7a45487b59c9cc438d9\n **/","/*This is where I need to import packages required for production...\nWebpack will bundle it from here, can't I also use the package.json to do that??\n*/\n\n/* eslint-disable no-unused-vars*/\n\nimport fetch from 'whatwg-fetch'\nimport {html, render} from 'lit-html';\n\n\n/** WEBPACK FOOTER **\n ** ./src/vendor.js\n **/","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/whatwg-fetch/fetch.js\n ** module id = 5\n ** module chunks = 1\n **/","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * TypeScript has a problem with precompiling templates literals\n * https://github.com/Microsoft/TypeScript/issues/17956\n *\n * TODO(justinfagnani): Run tests compiled to ES5 with both Babel and\n * TypeScript to verify correctness.\n */\nconst envCachesTemplates = ((t) => t() === t())(() => ((s) => s) ``);\n// The first argument to JS template tags retain identity across multiple\n// calls to a tag for the same literal, so we can cache work done per literal\n// in a Map.\nconst templates = new Map();\nconst svgTemplates = new Map();\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings, ...values) => litTag(strings, values, templates, false);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings, ...values) => litTag(strings, values, svgTemplates, true);\nfunction litTag(strings, values, templates, isSvg) {\n    const key = envCachesTemplates ?\n        strings :\n        strings.join('{{--uniqueness-workaround--}}');\n    let template = templates.get(key);\n    if (template === undefined) {\n        template = new Template(strings, isSvg);\n        templates.set(key, template);\n    }\n    return new TemplateResult(template, values);\n}\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(template, values) {\n        this.template = template;\n        this.values = values;\n    }\n}\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n */\nexport function render(result, container, partCallback = defaultPartCallback) {\n    let instance = container.__templateInstance;\n    // Repeat render, just call update()\n    if (instance !== undefined && instance.template === result.template &&\n        instance._partCallback === partCallback) {\n        instance.update(result.values);\n        return;\n    }\n    // First render, create a new TemplateInstance and append it\n    instance = new TemplateInstance(result.template, partCallback);\n    container.__templateInstance = instance;\n    const fragment = instance._clone();\n    instance.update(result.values);\n    let child;\n    while ((child = container.lastChild)) {\n        container.removeChild(child);\n    }\n    container.appendChild(fragment);\n}\n/**\n * An expression marker with embedded unique key to avoid\n * https://github.com/PolymerLabs/lit-html/issues/62\n */\nconst attributeMarker = `{{lit-${Math.random()}}}`;\n/**\n * Regex to scan the string preceding an expression to see if we're in a text\n * context, and not an attribute context.\n *\n * This works by seeing if we have a `>` not followed by a `<`. If there is a\n * `<` closer to the end of the strings, then we're inside a tag.\n */\nconst textRegex = />[^<]*$/;\nconst hasTagsRegex = /[^<]*/;\nconst textMarkerContent = '_-lit-html-_';\nconst textMarker = `<!--${textMarkerContent}-->`;\nconst attrOrTextRegex = new RegExp(`${attributeMarker}|${textMarker}`);\n/**\n * A placeholder for a dynamic expression in an HTML template.\n *\n * There are two built-in part types: AttributePart and NodePart. NodeParts\n * always represent a single dynamic expression, while AttributeParts may\n * represent as many expressions are contained in the attribute.\n *\n * A Template's parts are mutable, so parts can be replaced or modified\n * (possibly to implement different template semantics). The contract is that\n * parts can only be replaced, not removed, added or reordered, and parts must\n * always consume the correct number of values in their `update()` method.\n *\n * TODO(justinfagnani): That requirement is a little fragile. A\n * TemplateInstance could instead be more careful about which values it gives\n * to Part.update().\n */\nexport class TemplatePart {\n    constructor(type, index, name, rawName, strings) {\n        this.type = type;\n        this.index = index;\n        this.name = name;\n        this.rawName = rawName;\n        this.strings = strings;\n    }\n}\nexport class Template {\n    constructor(strings, svg = false) {\n        this.parts = [];\n        this.svg = svg;\n        this.element = document.createElement('template');\n        this.element.innerHTML = this._getHtml(strings, svg);\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(this.element.content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n               NodeFilter.SHOW_TEXT */, null, false);\n        let index = -1;\n        let partIndex = 0;\n        const nodesToRemove = [];\n        // The actual previous node, accounting for removals: if a node is removed\n        // it will never be the previousNode.\n        let previousNode;\n        // Used to set previousNode at the top of the loop.\n        let currentNode;\n        while (walker.nextNode()) {\n            index++;\n            previousNode = currentNode;\n            const node = currentNode = walker.currentNode;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (!node.hasAttributes()) {\n                    continue;\n                }\n                const attributes = node.attributes;\n                for (let i = 0; i < attributes.length; i++) {\n                    const attribute = attributes.item(i);\n                    const attributeStrings = attribute.value.split(attrOrTextRegex);\n                    if (attributeStrings.length > 1) {\n                        // Get the template literal section leading up to the first\n                        // expression in this attribute attribute\n                        const attributeString = strings[partIndex];\n                        // Trim the trailing literal value if this is an interpolation\n                        const rawNameString = attributeString.substring(0, attributeString.length - attributeStrings[0].length);\n                        // Find the attribute name\n                        const rawName = rawNameString.match(/((?:\\w|[.\\-_$])+)=[\"']?$/)[1];\n                        this.parts.push(new TemplatePart('attribute', index, attribute.name, rawName, attributeStrings));\n                        node.removeAttribute(attribute.name);\n                        partIndex += attributeStrings.length - 1;\n                        i--;\n                    }\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const nodeValue = node.nodeValue;\n                const strings = nodeValue.split(attributeMarker);\n                if (strings.length > 1) {\n                    const parent = node.parentNode;\n                    const lastIndex = strings.length - 1;\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                    // We keep this current node, but reset its content to the last\n                    // literal part. We insert new literal nodes before this so that the\n                    // tree walker keeps its position correctly.\n                    node.textContent = strings[lastIndex];\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        parent.insertBefore(document.createTextNode(strings[i]), node);\n                        this.parts.push(new TemplatePart('node', index++));\n                    }\n                }\n                else {\n                    // Strip whitespace-only nodes, only between elements, or at the\n                    // beginning or end of elements.\n                    const previousSibling = node.previousSibling;\n                    const nextSibling = node.nextSibling;\n                    if ((previousSibling === null ||\n                        previousSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&\n                        (nextSibling === null ||\n                            nextSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&\n                        nodeValue.trim() === '') {\n                        nodesToRemove.push(node);\n                        currentNode = previousNode;\n                        index--;\n                    }\n                }\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */ &&\n                node.nodeValue === textMarkerContent) {\n                const parent = node.parentNode;\n                // If we don't have a previous node add a marker node.\n                // If the previousSibling is removed, because it's another part\n                // placholder, or empty text, add a marker node.\n                if (node.previousSibling === null ||\n                    node.previousSibling !== previousNode) {\n                    parent.insertBefore(new Text(), node);\n                }\n                else {\n                    index--;\n                }\n                this.parts.push(new TemplatePart('node', index++));\n                nodesToRemove.push(node);\n                // If we don't have a next node add a marker node.\n                // We don't have to check if the next node is going to be removed,\n                // because that node will induce a marker if so.\n                if (node.nextSibling === null) {\n                    parent.insertBefore(new Text(), node);\n                }\n                else {\n                    index--;\n                }\n                currentNode = previousNode;\n                partIndex++;\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n    /**\n     * Returns a string of HTML used to create a <template> element.\n     */\n    _getHtml(strings, svg) {\n        const l = strings.length;\n        const a = [];\n        let isTextBinding = false;\n        for (let i = 0; i < l - 1; i++) {\n            const s = strings[i];\n            a.push(s);\n            // We're in a text position if the previous string matches the\n            // textRegex. If it doesn't and the previous string has no tags, then\n            // we use the previous text position state.\n            isTextBinding = s.match(textRegex) !== null ||\n                (s.match(hasTagsRegex) !== null && isTextBinding);\n            a.push(isTextBinding ? textMarker : attributeMarker);\n        }\n        a.push(strings[l - 1]);\n        const html = a.join('');\n        return svg ? `<svg>${html}</svg>` : html;\n    }\n}\nexport const getValue = (part, value) => {\n    // `null` as the value of a Text node will render the string 'null'\n    // so we convert it to undefined\n    if (value != null && value.__litDirective === true) {\n        value = value(part);\n    }\n    return value === null ? undefined : value;\n};\nexport const directive = (f) => {\n    f.__litDirective = true;\n    return f;\n};\nexport class AttributePart {\n    constructor(instance, element, name, strings) {\n        this.instance = instance;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.size = strings.length - 1;\n    }\n    setValue(values, startIndex) {\n        const strings = this.strings;\n        let text = '';\n        for (let i = 0; i < strings.length; i++) {\n            text += strings[i];\n            if (i < strings.length - 1) {\n                const v = getValue(this, values[startIndex + i]);\n                if (v &&\n                    (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n                    for (const t of v) {\n                        // TODO: we need to recursively call getValue into iterables...\n                        text += t;\n                    }\n                }\n                else {\n                    text += v;\n                }\n            }\n        }\n        this.element.setAttribute(this.name, text);\n    }\n}\nexport class NodePart {\n    constructor(instance, startNode, endNode) {\n        this.instance = instance;\n        this.startNode = startNode;\n        this.endNode = endNode;\n        this._previousValue = undefined;\n    }\n    setValue(value) {\n        value = getValue(this, value);\n        if (value === null ||\n            !(typeof value === 'object' || typeof value === 'function')) {\n            // Handle primitive values\n            // If the value didn't change, do nothing\n            if (value === this._previousValue) {\n                return;\n            }\n            this._setText(value);\n        }\n        else if (value instanceof TemplateResult) {\n            this._setTemplateResult(value);\n        }\n        else if (Array.isArray(value) || value[Symbol.iterator]) {\n            this._setIterable(value);\n        }\n        else if (value instanceof Node) {\n            this._setNode(value);\n        }\n        else if (value.then !== undefined) {\n            this._setPromise(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._setText(value);\n        }\n    }\n    _insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    _setNode(value) {\n        this.clear();\n        this._insert(value);\n        this._previousValue = value;\n    }\n    _setText(value) {\n        const node = this.startNode.nextSibling;\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === Node.TEXT_NODE) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if _previousValue is\n            // primitive?\n            node.textContent = value;\n        }\n        else {\n            this._setNode(document.createTextNode(value === undefined ? '' : value));\n        }\n        this._previousValue = value;\n    }\n    _setTemplateResult(value) {\n        let instance;\n        if (this._previousValue &&\n            this._previousValue.template === value.template) {\n            instance = this._previousValue;\n        }\n        else {\n            instance =\n                new TemplateInstance(value.template, this.instance._partCallback);\n            this._setNode(instance._clone());\n            this._previousValue = instance;\n        }\n        instance.update(value.values);\n    }\n    _setIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _previousValue is an array, then the previous render was of an\n        // iterable and _previousValue will contain the NodeParts from the previous\n        // render. If _previousValue is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this._previousValue)) {\n            this.clear();\n            this._previousValue = [];\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this._previousValue;\n        let partIndex = 0;\n        for (const item of value) {\n            // Try to reuse an existing part\n            let itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                // If we're creating the first item part, it's startNode should be the\n                // container's startNode\n                let itemStart = this.startNode;\n                // If we're not creating the first part, create a new separator marker\n                // node, and fix up the previous part's endNode to point to it\n                if (partIndex > 0) {\n                    const previousPart = itemParts[partIndex - 1];\n                    itemStart = previousPart.endNode = document.createTextNode('');\n                    this._insert(itemStart);\n                }\n                itemPart = new NodePart(this.instance, itemStart, this.endNode);\n                itemParts.push(itemPart);\n            }\n            itemPart.setValue(item);\n            partIndex++;\n        }\n        if (partIndex === 0) {\n            this.clear();\n            this._previousValue = undefined;\n        }\n        else if (partIndex < itemParts.length) {\n            const lastPart = itemParts[partIndex - 1];\n            // Truncate the parts array so _previousValue reflects the current state\n            itemParts.length = partIndex;\n            this.clear(lastPart.endNode.previousSibling);\n            lastPart.endNode = this.endNode;\n        }\n    }\n    _setPromise(value) {\n        value.then((v) => {\n            if (this._previousValue === value) {\n                this.setValue(v);\n            }\n        });\n        this._previousValue = value;\n    }\n    clear(startNode = this.startNode) {\n        let node;\n        while ((node = startNode.nextSibling) !== this.endNode) {\n            node.parentNode.removeChild(node);\n        }\n    }\n}\nexport const defaultPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        return new AttributePart(instance, node, templatePart.name, templatePart.strings);\n    }\n    else if (templatePart.type === 'node') {\n        return new NodePart(instance, node, node.nextSibling);\n    }\n    throw new Error(`Unknown part type ${templatePart.type}`);\n};\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n    constructor(template, partCallback = defaultPartCallback) {\n        this._parts = [];\n        this.template = template;\n        this._partCallback = partCallback;\n    }\n    update(values) {\n        let valueIndex = 0;\n        for (const part of this._parts) {\n            if (part.size === undefined) {\n                part.setValue(values[valueIndex]);\n                valueIndex++;\n            }\n            else {\n                part.setValue(values, valueIndex);\n                valueIndex += part.size;\n            }\n        }\n    }\n    _clone() {\n        const fragment = document.importNode(this.template.element.content, true);\n        if (this.template.parts.length > 0) {\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT */, null, false);\n            const parts = this.template.parts;\n            let index = 0;\n            let partIndex = 0;\n            let templatePart = parts[0];\n            let node = walker.nextNode();\n            while (node != null && partIndex < parts.length) {\n                if (index === templatePart.index) {\n                    this._parts.push(this._partCallback(this, templatePart, node));\n                    templatePart = parts[++partIndex];\n                }\n                else {\n                    index++;\n                    node = walker.nextNode();\n                }\n            }\n        }\n        if (this.template.svg) {\n            const svgElement = fragment.firstChild;\n            fragment.removeChild(svgElement);\n            const nodes = svgElement.childNodes;\n            for (let i = 0; i < nodes.length; i++) {\n                fragment.appendChild(nodes.item(i));\n            }\n        }\n        return fragment;\n    }\n}\n//# sourceMappingURL=lit-html.js.map\n\n\n/** WEBPACK FOOTER **\n ** ./~/lit-html/lit-html.js\n **/"],"sourceRoot":""}